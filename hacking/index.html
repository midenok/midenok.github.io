<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF8"><title>Hacking Curriculum Vitae</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="ru" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idp8910921008"></a>Hacking Curriculum Vitae</h1></div><div><h2 class="subtitle">А. С. Миденков</h2></div><div><p class="copyright">Авторские права © 2016 Aleksey Midenkov</p></div></div><hr></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="chapter"><a href="#ch1">1. Миденков Алексей Сергеевич</a></span></dt><dd><dl><dt><span class="sect1"><a href="#s1">1. Краткая информация</a></span></dt><dt><span class="sect1"><a href="#s3">2. Обо мне</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ch2">2. Опыт реверсинга</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8911777376">1. Коротко о методике</a></span></dt><dd><dl><dt><span class="sect2"><a href="#method_1">1.1. Определение адреса интересуемой функции</a></span></dt><dt><span class="sect2"><a href="#idp8913829232">1.2. Анализ интересуемой функции</a></span></dt><dt><span class="sect2"><a href="#idp8912988064">1.3. Внесение перманентных изменений</a></span></dt></dl></dd><dt><span class="sect1"><a href="#art2-1">2. Примеры работ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp8911924432">2.1. Evoxy: libev-based HTTP proxy</a></span></dt><dt><span class="sect2"><a href="#idp8913919312">2.2. Atomic Bomberman</a></span></dt><dt><span class="sect2"><a href="#idp8911594752">2.3. ARTiSAN Real-time Studio</a></span></dt><dt><span class="sect2"><a href="#idp8912602320">2.4. SecureCRT</a></span></dt><dt><span class="sect2"><a href="#idp8911305376">2.5. Windows XP: подключение к адресному пространству процесса</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ch1"></a>Глава 1. Миденков Алексей Сергеевич</h1></div></div></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="sect1"><a href="#s1">1. Краткая информация</a></span></dt><dt><span class="sect1"><a href="#s3">2. Обо мне</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="s1"></a>1. Краткая информация</h2></div></div></div><p>
        </p><table width="100%" cellpadding="0" cellspacing="0" border="0" frame="void" id="idp8911424112"><col width="75%" align="left"><col width="25%" align="right"><tr>
            <td valign="top" align="left">
              <table border="0" summary="Simple list" class="simplelist"><tr><td>Дата и место рождения: 18 августа 1978 г., город Кемерово</td></tr><tr><td>Телефон: +7 905 901 6065</td></tr><tr><td>E-mail: <a class="ulink" href="mailto:midenok@bk.ru" target="_top">midenok@bk.ru</a>; Skype:
                  midenok</td></tr><tr><td>Резюме: <a class="ulink" href="https://kemerovo.hh.ru/applicant/resumes/view?resume=24315b02ff020dba580039ed1f586d44436a41" target="_top">Ведущий разработчик</a>
                </td></tr><tr><td>Образование: ТУСУР (г. Томск), специальность АСОиУ</td></tr></table>
            </td>
            <td valign="top" align="right">
              <a class="ulink" href="images/mid-cv.jpg" target="_top"><span class="inlinemediaobject"><img src="images/mid-cv.jpg" width="124.015748031496" height="124.015748031496"></span></a>
            </td>
          </tr></table><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="s3"></a>2. Обо мне</h2></div></div></div><p>Я проработал программистом в крупной международной компании в Москве ни много ни
        мало 8 лет, а до этого ещё около 8-и лет работал системным администратором в Кемерово. Мой
        московский опыт принёс мне много знаний и умений, но в то же время и разочарование.
        Разочарование пришло наверное потому, что структура крупного офиса со штатом около ста
        человек не давала мне нужной свободы и в то же время качество общепринятых стандартов
        оставляло желать лучшего, с чем мне приходилось ежедневно мириться. Вобщем увольнение из той
        компании было как освобождение. Но, с другой стороны, финансовая свобода и возможность
        общения с интересными людьми, а также с увлечёнными высококлассными специалистами (конечно,
        и такие там были) -- это то, чего я лишился.</p><p>Что же я могу сказать про свою собственную степень увлечённости? Навереное, её теперь
        нет... Не знаю, почему -- может быть из-за московского офиса, а может быть потому что просто
        вырос. С детства я был сильно увлечён компьютерами -- MS DOS 3.0, потом 3.3, ковыряние
        autoexec-а, коробки 5-дюймовых дискет с игрушками, с которыми я таскался по школе... Мне
        хотелось проникнуть в самую глубину всего -- и на Бейсике программировал, и Си изучал, и
        книгу по Ассемблеру читал. А как только встретил книгу по архитектуре 386-го процессора, тут
        же стал её изучать (хотя она меня жутко вгоняла в сон). Потом появился Linux, я был одним из
        первых в городе, у кого был Debian на 4-х CD. Ну вот, так это всё закрутилось,
        завертелось.</p><p>Что касается хакерского интереса, то конечно я хотел им быть. Раздобытые с Usenet-а и
        Fido хакерские мануалы притягивали своей романтикой. А ночи проведённые за SoftICE-ом
        приносили упоение победой от крупицы нового достижения. Теперь-то я понимаю, что по своим
        аналитическим способностям, да и в целом по интеллекту я был что ни есть самый середнячок.
        Но беспрецедентная преданность своему увлечению толкала меня вперёд и давала неплохие
        результаты. Сначала место в небедствующей торговой фирме, маленькой и уютной, с зарплатой в
        разы превышающей среднюю по городу. Затем радиосеть из более 100 точек по городу -- рай для
        трудоголика. Потом Москву...</p><p>Теперь у меня нет той самой бескомпромиссной увлечённости. Что дальше? На звонки из
        Яндекса я смотрю с изрядной долей скепсиса, ещё один московский офис я не потяну.
        Разрисованные стены и бесплатные, мать их, печенюшки -- кого они хотят этим заманить...
        Покер? Что-то я не получаю от него того, чего ожидаю, и так может продолжаться ещё лет 10.
        Юго-Восточная Азия? Да, там есть интересные российские компании и от "офисной тоски"
        есть шанс увернуться, возможно туда. Но вцелом, я в состоянии неизвестности. А
        возраст-то уже, так сказать, не предрасположен к рисковым ситуациям. Полжизни прошло, ещё
        полжизни пролетит, не успеешь и глазом моргнуть!</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ch2"></a>Глава 2. Опыт реверсинга</h1></div></div></div><div class="toc"><p><b>Содержание</b></p><dl><dt><span class="sect1"><a href="#idp8911777376">1. Коротко о методике</a></span></dt><dd><dl><dt><span class="sect2"><a href="#method_1">1.1. Определение адреса интересуемой функции</a></span></dt><dt><span class="sect2"><a href="#idp8913829232">1.2. Анализ интересуемой функции</a></span></dt><dt><span class="sect2"><a href="#idp8912988064">1.3. Внесение перманентных изменений</a></span></dt></dl></dd><dt><span class="sect1"><a href="#art2-1">2. Примеры работ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idp8911924432">2.1. Evoxy: libev-based HTTP proxy</a></span></dt><dt><span class="sect2"><a href="#idp8913919312">2.2. Atomic Bomberman</a></span></dt><dt><span class="sect2"><a href="#idp8911594752">2.3. ARTiSAN Real-time Studio</a></span></dt><dt><span class="sect2"><a href="#idp8912602320">2.4. SecureCRT</a></span></dt><dt><span class="sect2"><a href="#idp8911305376">2.5. Windows XP: подключение к адресному пространству процесса</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8911777376"></a>1. Коротко о методике</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="method_1"></a>1.1. Определение адреса интересуемой функции</h3></div></div></div><p>Прежде всего, нужно выбрать внешний вызов (системный или библиотечный), который
          предположительно используется в интересуемой функции и не используется или используется
          редко до её вызова. Чаще всего это будет read (ReadFile, ReadFileEx), если функция
          использует данные из файла либо GetWindowText, если пользователь вводит данные. На этом
          этапе могут хорошо помочь трассирующие утилиты (Procmon, strace и т.п.).</p><p>Встать в отладчике на этот вызов и проверить попадаем ли мы в него при активации
          интересуемой функции в UI. Если мы попадаем очень часто в этот вызов до активации функции,
          то значит либо вызов выбран некорректно и нужно выбрать другой, либо если лучших вариантов
          нет, то отфильтровать по входящим параметрам (например open по имени файла, read по файл
          дескриптору и т.д.). Либо найти методом бинарного поиска количества пропусков
          breakpoint-ов, если входящие данные стабильны и число вызовов не меняется.</p><p><a name="method_difficulties"></a>Также могут быть осложнения, если вызов используется до
          интересуемой функции. Например, данные считываются в буфер, а затем буфер передаётся
          интересуемой функции. В таком случае, нужно ставить breakpoint на чтение участка памяти
          буфера, отслеживать все его копирования и чтения его копий до тех пор, пока эта цепочка не
          приведёт нас к интересуемой функции.</p><p>Итак, мы научились останавливать отладчик при вызове интересуемой функции. Осталось
          определить на каком уровне стека вызовов она находится (т.к. мы в данный момент в
          системном вызове где-то в самом низу). Это делается методом анализа пересечений стеков.
          Сохраняем данный стек, где мы знаем, что интересуемая функция присутствует. И берём другой
          стек, где мы знаем, что интересуемая функция отсутствует. Второй стек должен быть
          максимально близкий по времени исполнения к первому. Отбрасываем общую верхнюю часть -- и
          получаем адрес возврата в интересуемую функцию.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8913829232"></a>1.2. Анализ интересуемой функции</h3></div></div></div><p>На данном этапе производится поименование переменных и вызовов внутри функции.
                    Это делается на основе следующих данных:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>статические строки в коде (например: 'Wins', значит участок кода
                                выводит число побед)</p></li><li class="listitem"><p>библиотечные и системные вызовы и константы (как правило не
                                утратили читабельные имена)</p></li><li class="listitem"><p>динамические данные времени исполнения (всегда можно посмотреть в
                                отладчике, какое значение принимает переменная)</p></li><li class="listitem"><p>метод проб и ошибок: вносим изменения в исполняемый код, например
                                правим условный переход или значение регистра и смотрим изменения в
                                поведении программы.</p></li></ul></div><p>Не стоит пренебрегать анализом динамики исполнения. Встать в отладчике в
                    изучаемый участок кода и проанализировать данные и стеки вызовов. И так,
                    потихоньку клубок распутывается.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8912988064"></a>1.3. Внесение перманентных изменений</h3></div></div></div><p>Если вносимые изменения не требуют увеличения размера исполняемого кода, то
                    задача сводится к тривиальной перезаписи участков кода. Если при этом некоторый
                    существующий код упраздняется, то на его месте может быть записан новый код.
                    Если же места под новый код недостаточно, то требуется увеличение секции кода и
                    пересборка исполняемого файла.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="art2-1"></a>2. Примеры работ</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8911924432"></a>2.1. Evoxy: libev-based HTTP proxy</h3></div></div></div><pre class="synopsis">Год: 2016
Инструментарий: С++11, POSIX, libev
Ссылка на Github: <a class="ulink" href="https://github.com/midenok/evoxy" target="_top">Evoxy</a></pre><p>Пример
          не демонстрирует навыки реверсинга. Однако, это то чем я занимаюсь на данный момент,
          поэтому стоит его здесь указать. </p><p>Программа написана на C++ с использованием элементов 11-го стандарта. Архитектура
          демона основана на неблокирующихся сокетах и состоит из пула потоков, в каждом из которых
          запущен цикл событий, обрабатывающий все принятые в данном потоке соединения. Программа
          работает на преаллоцированной памяти, у каждого потока есть свой пул памяти, аллокация из
          кучи происходит только на стадии инициализации приложения. Из пула блок памяти берётся при
          новом соединении и возвращается обратно при закрытии соединения. Вся обработка соединения
          происходит на статической памяти внутри этого блока. Подробнее об архитектуре приложения
          можно узнать из <a class="ulink" href="https://github.com/midenok/server-demo/blob/master/README.md" target="_top">описания</a> к моему проекту server-demo.</p><p>Текущий статус проекта: основная функциональность RFC 2616 реализована, проект
          находится на стадии альфа-тестирования. Программа успешно справляется со множеством
          длинных сhunked запросов через keep-alive соединение.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8913919312"></a>2.2. Atomic Bomberman</h3></div></div></div><p>
                    </p><table frame="void" width="100%" cellpadding="0" cellspacing="0" id="idp8913508032"><col width="50%" align="left"><col width="50%" align="right"><thead></thead><tbody><tr>
                <td valign="bottom">
                  <pre class="synopsis">Год: 2013
Инструментарий: Ida Pro 6.1; Syser 1.99</pre>
                </td>
                <td align="right"><a class="ulink" href="images/atomic-bomberman.jpg" target="_top"><span class="inlinemediaobject"><img src="images/atomic-bomberman.jpg" align="right" width="177"></span></a></td>
              </tr></tbody></table><p>
                </p><p>В ходе анализа кода игры <a class="ulink" href="https://en.wikipedia.org/wiki/Atomic_Bomberman" target="_top">Atomic Bomberman</a> были
          найдены функции, отвечающие за работу основного меню ($main_menu_loop), запуска новой игры
          ($new_game_options, $new_game_players, $new_game), работу настроек игры ($options_menu,
          $load_options), а также основные игровые переменные, такие как $newgame_goal_amount,
          $goal_type, $newgame_theme. Все символы с '$' были разработаны мной в процессе реверсинга,
          полный их список (73) можно посмотреть в <a class="ulink" href="files/bm95_discovered.map" target="_top">bm95_discovered.map</a>. Заметки по анализу находятся в <a class="ulink" href="files/bomberman.txt" target="_top">bomberman.txt</a>.</p><p><a class="ulink" href="images/BM95-IDA.png" target="_top"><span class="inlinemediaobject"><img src="images/BM95-IDA.png" width="620"></span></a></p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8911594752"></a>2.3. ARTiSAN Real-time Studio</h3></div></div></div><pre class="synopsis">Год: 2003(?)
Инструментарий: SoftICE, etc.</pre><p>Исправляет требование лицензионного ключа. К сожалению, в этом и более ранних примерах
          история анализа не сохранялась. Breakpoint ставился на GetWindowText(), который возвращал
          введённые пользователем данные. Затем происходил долгий и мучительный подъём по стеку (я
          тогда не анализировал пересечения стеков) до тех пор, пока не был найден условный переход
          после возврата с уровня, который активно "мурыжил" эти данные. Подправив этот условный
          переход -- вуаля: "Спасибо, что зарегистрировались!". </p><pre class="programlisting">#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;mem.h&gt;

#define MAXBUF 100
char buf[MAXBUF];
char * filename = "rtsme.exe";
#define FILESIZE 6553600
#define LENGTH 5
char check[LENGTH] = { 0xe8, 0xa6, 0x05, 0xf2, 0xff };
char patch[LENGTH] = { 0x33, 0xc0, 0x40, 0x90, 0x90 };
#define OFFSET 0xe91c8

#define msgh(handle, fmt) fprintf(handle, fmt, filename)
#define err(fmt) msgh(stderr, fmt)
#define msg(fmt) msgh(stdout, fmt)

int main()
{
	int f;
	struct stat s;
	char buf[LENGTH];
	printf("ARTiSAN Real-time Studio v4.2.48.0 dirty crack by +....\n");
	if ((f = open(filename, O_RDWR))==-1) {
		err("Error opening %s!\n");
		return 1;
	}
	fstat(f, &amp;s);
	if (s.st_size != FILESIZE) {
		err("%s size mismatch!\n");
		return 1;
	}
	lseek(f, OFFSET, SEEK_SET);
	read(f, buf, LENGTH);
	if (memcmp(buf, check, LENGTH)) {
		err("Maybe %s already patched?\n");
		return 1;
	}
	lseek(f, OFFSET, SEEK_SET);
	if (LENGTH==write(f, patch, LENGTH)) {
		msg("%s successfully patched.\n");
		return 0;
	}
	err("Failed to write %s!\n");
	return 1;
}</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8912602320"></a>2.4. SecureCRT</h3></div></div></div><pre class="synopsis">Год: 2002(?)
Инструментарий: SoftICE, etc.</pre><p>Исправляет жалобу программы на плохую лицензию. В этом примере, как и было сказано в
            <a class="link" href="#method_difficulties">описании методики</a>, данные, прочитанные из
          файла по цепочке перекладывались с места на место.</p><p>
          </p><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#pragma hdrstop

const char * EXENAME = "SecureCRT.exe";
const size_t OFFSET = 0x48d5f;
#define CHECKLEN 17
typedef unsigned char byte_t;
const byte_t CHECK[CHECKLEN] = {0x84, 0xc0, 0x0f, 0x84, 0x84,
        0, 0, 0, 0x8d, 0x4c, 0x24, 0x6c, 0xe8, 0xd6, 0x98,
        7, 0};
#pragma argsused
int main(int argc, char* argv[])
{
        char buf[CHECKLEN];
        FILE * exe = fopen(EXENAME, "r+");
        printf ("One byte crack by +.... for SecureCRT 4.1.0.138\n");
        if (! exe) {
                fprintf(stderr, "Open %s failed!\n", EXENAME);
                return 1;
        }
        fseek(exe, OFFSET, 0);
        if (CHECKLEN != fread(buf, 1, CHECKLEN, exe)) {
                fprintf(stderr, "Read %s failed!\n", EXENAME);
                return 1;
        }
        if (memcmp(buf, CHECK, CHECKLEN)) {
                fprintf(stderr, "Check %s failed!\n", EXENAME);
                return 1;
        }
        fseek(exe, OFFSET, 0);
        fprintf(exe, "\x32");
        fclose(exe);
        printf ("0x32 written at 0x%x.\
Now all protocols work with all these 4.0 licenses you can find on astalavista\
and usenet. Enjoy!\n", OFFSET);
        return 0;
}</pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idp8911305376"></a>2.5. Windows XP: подключение к адресному пространству процесса</h3></div></div></div><p>
          </p><pre class="synopsis">Год: 2002</pre><p>
        </p><p>Пример демонстрирует возможность вторжения в адресное пространство процесса. Основано
          на статье от
          +z0mbie.</p><pre class="programlisting">//---------------------------------------------------------------------------
#include &lt;iostream&gt;
#include &lt;windows.h&gt;
#pragma hdrstop

using namespace std;
//---------------------------------------------------------------------------

#pragma argsused
int main(int argc, char* argv[])
{
    LPCTSTR app = "&lt;path to EXE&gt;";
    STARTUPINFO i = {0};
    i.cb = sizeof(STARTUPINFO);
    i.lpDesktop = "WinSta0\\Default";
    PROCESS_INFORMATION p;
	bool res = CreateProcess(app, NULL, NULL, NULL, TRUE,
    	NULL, NULL, NULL, &amp;i, &amp;p);
    if (!res) {
        DWORD e = GetLastError();
        char msg[50];
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, e, 0x419, msg, 49, NULL);
        cout &lt;&lt; "Process creation error: "&lt;&lt;msg&lt;&lt;"\n";
        return 1;
    } else {
        cout &lt;&lt; "Process created. About to change context: press any key... ";
        getchar();
    }
    CONTEXT tc;
    res = GetThreadContext(p.hThread, &amp;tc);
    if (!res) {
        cout &lt;&lt; "GetThreadContext: error\n";
        return 1;
    }
    res = SetThreadContext(GetCurrentThread(), &amp;tc);
    if (!res) {
        cout &lt;&lt; "SetThreadContext: error\n";
        return 1;
    }
    WORD b = *(int *)0x40569d; // type interesting address inside EXE
    cout &lt;&lt; "All is well "&lt;&lt; b &lt;&lt; "\n";
    getchar();
    return 0;
}
//---------------------------------------------------------------------------</pre></div></div></div></div></body></html>
