<?xml version='1.0' encoding="UTF8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"/usr/share/sgml/docbook/xml-dtd-4.5/docbookx.dtd">

<book lang="ru">
    <bookinfo>
        <title>Hacking Curriculum Vitae</title>
        <subtitle>А. С. Миденков</subtitle>
        <copyright>
            <year>2016</year>
            <holder>Aleksey Midenkov</holder>
        </copyright>
    </bookinfo>
    <chapter id="ch1">
        <title>Миденков Алексей Сергеевич</title>
        <sect1 id="s1">
            <title>Краткая информация</title>
      <para>
        <informaltable width="100%" cellpadding="0" cellspacing="0" border="0" frame="void">
          <col width="75%" align="left"/>
          <col width="25%" align="right"/>
          <tr>
            <td valign="top" align="left">
              <simplelist>
                <member>Дата и место рождения: 18 августа 1978 г., город Кемерово</member>
                <member>Телефон: +7 905 901 6065</member>
                <member>E-mail: <ulink url="mailto:midenok@bk.ru">midenok@bk.ru</ulink>; Skype:
                  midenok</member>
                <member>Резюме: <ulink
                    url="https://kemerovo.hh.ru/applicant/resumes/view?resume=24315b02ff020dba580039ed1f586d44436a41"
                    >Ведущий разработчик</ulink>
                </member>
                <member>Образование: ТУСУР (г. Томск), специальность АСОиУ</member>
              </simplelist>
            </td>
            <td valign="top" align="right">
              <ulink url="images/mid-cv.jpg"><inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="images/mid-cv.jpg" contentwidth="3.5cm" contentdepth="3.5cm"
                      format="JPG" valign="top"/>
                  </imageobject>
                </inlinemediaobject></ulink>
            </td>
          </tr>
        </informaltable>
      </para>
            <!--        <para>
            Вся информация должна быть открыта! 
        </para>
-->
        </sect1>
        <sect1 id="s3">
            <title>Обо мне</title>
            <para>Я проработал программистом в крупной международной компании в Москве ни много ни
        мало 8 лет, а до этого ещё около 8-и лет работал системным администратором в Кемерово. Мой
        московский опыт принёс мне много знаний и умений, но в то же время и разочарование.
        Разочарование пришло наверное потому, что структура крупного офиса со штатом около ста
        человек не давала мне нужной свободы и в то же время качество общепринятых стандартов
        оставляло желать лучшего, с чем мне приходилось ежедневно мириться. Вобщем увольнение из той
        компании было как освобождение. Но, с другой стороны, финансовая свобода и возможность
        общения с интересными людьми, а также с увлечёнными высококлассными специалистами (конечно,
        и такие там были) -- это то, чего я лишился.</para>
      <para>Что же я могу сказать про свою собственную степень увлечённости? Навереное, её теперь
        нет... Не знаю, почему -- может быть из-за московского офиса, а может быть потому что просто
        вырос. С детства я был сильно увлечён компьютерами -- MS DOS 3.0, потом 3.3, ковыряние
        autoexec-а, коробки 5-дюймовых дискет с игрушками, с которыми я таскался по школе... Мне
        хотелось проникнуть в самую глубину всего -- и на Бейсике программировал, и Си изучал, и
        книгу по Ассемблеру читал. А как только встретил книгу по архитектуре 386-го процессора, тут
        же стал её изучать (хотя она меня жутко вгоняла в сон). Потом появился Linux, я был одним из
        первых в городе, у кого был Debian на 4-х CD. Ну вот, так это всё закрутилось,
        завертелось.</para>
      <para>Что касается хакерского интереса, то конечно я хотел им быть. Раздобытые с Usenet-а и
        Fido хакерские мануалы притягивали своей романтикой. А ночи проведённые за SoftICE-ом
        приносили упоение победой от крупицы нового достижения. Теперь-то я понимаю, что по своим
        аналитическим способностям, да и в целом по интеллекту я был что ни есть самый середнячок.
        Но беспрецедентная преданность своему увлечению толкала меня вперёд и давала неплохие
        результаты. Сначала место в небедствующей торговой фирме, маленькой и уютной, с зарплатой в
        разы превышающей среднюю по городу. Затем радиосеть из более 100 точек по городу -- рай для
        трудоголика. Потом Москву...</para>
      <para>Теперь у меня нет той самой бескомпромиссной увлечённости. Что дальше? На звонки из
        Яндекса я смотрю с изрядной долей скепсиса, ещё один московский офис я не потяну.
        Разрисованные стены и бесплатные, мать их, печенюшки -- кого они хотят этим заманить...
        Покер? Что-то я не получаю от него того, чего ожидаю, и так может продолжаться ещё лет 10.
        Юго-Восточная Азия? Да, там есть интересные российские компании и от "офисной тоски"
        есть шанс увернуться, возможно туда. Но вцелом, я в состоянии неизвестности. А
        возраст-то уже, так сказать, не предрасположен к рисковым ситуациям. Полжизни прошло, ещё
        полжизни пролетит, не успеешь и глазом моргнуть!</para>
        </sect1>
    </chapter>
    <chapter id="ch2">
        <title>Опыт реверсинга</title>
        <sect1>
            <title>Коротко о методике</title>
            <sect2 id="method_1">
        <title>Определение адреса интересуемой функции</title>
        <para>Прежде всего, нужно выбрать внешний вызов (системный или библиотечный), который
          предположительно используется в интересуемой функции и не используется или используется
          редко до её вызова. Чаще всего это будет read (ReadFile, ReadFileEx), если функция
          использует данные из файла либо GetWindowText, если пользователь вводит данные. На этом
          этапе могут хорошо помочь трассирующие утилиты (Procmon, strace и т.п.).</para>
        <para>Встать в отладчике на этот вызов и проверить попадаем ли мы в него при активации
          интересуемой функции в UI. Если мы попадаем очень часто в этот вызов до активации функции,
          то значит либо вызов выбран некорректно и нужно выбрать другой, либо если лучших вариантов
          нет, то отфильтровать по входящим параметрам (например open по имени файла, read по файл
          дескриптору и т.д.). Либо найти методом бинарного поиска количества пропусков
          breakpoint-ов, если входящие данные стабильны и число вызовов не меняется.</para>
        <para id="method_difficulties">Также могут быть осложнения, если вызов используется до
          интересуемой функции. Например, данные считываются в буфер, а затем буфер передаётся
          интересуемой функции. В таком случае, нужно ставить breakpoint на чтение участка памяти
          буфера, отслеживать все его копирования и чтения его копий до тех пор, пока эта цепочка не
          приведёт нас к интересуемой функции.</para>
        <para>Итак, мы научились останавливать отладчик при вызове интересуемой функции. Осталось
          определить на каком уровне стека вызовов она находится (т.к. мы в данный момент в
          системном вызове где-то в самом низу). Это делается методом анализа пересечений стеков.
          Сохраняем данный стек, где мы знаем, что интересуемая функция присутствует. И берём другой
          стек, где мы знаем, что интересуемая функция отсутствует. Второй стек должен быть
          максимально близкий по времени исполнения к первому. Отбрасываем общую верхнюю часть -- и
          получаем адрес возврата в интересуемую функцию.</para>
      </sect2>
            <sect2>
                <title>Анализ интересуемой функции</title>
                <para>На данном этапе производится поименование переменных и вызовов внутри функции.
                    Это делается на основе следующих данных:<itemizedlist>
                        <listitem>
                            <para>статические строки в коде (например: 'Wins', значит участок кода
                                выводит число побед)</para>
                        </listitem>
                        <listitem>
                            <para>библиотечные и системные вызовы и константы (как правило не
                                утратили читабельные имена)</para>
                        </listitem>
                        <listitem>
                            <para>динамические данные времени исполнения (всегда можно посмотреть в
                                отладчике, какое значение принимает переменная)</para>
                        </listitem>
                        <listitem>
                            <para>метод проб и ошибок: вносим изменения в исполняемый код, например
                                правим условный переход или значение регистра и смотрим изменения в
                                поведении программы.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Не стоит пренебрегать анализом динамики исполнения. Встать в отладчике в
                    изучаемый участок кода и проанализировать данные и стеки вызовов. И так,
                    потихоньку клубок распутывается.</para>
            </sect2>
            <sect2>
                <title>Внесение перманентных изменений</title>
                <para>Если вносимые изменения не требуют увеличения размера исполняемого кода, то
                    задача сводится к тривиальной перезаписи участков кода. Если при этом некоторый
                    существующий код упраздняется, то на его месте может быть записан новый код.
                    Если же места под новый код недостаточно, то требуется увеличение секции кода и
                    пересборка исполняемого файла.</para>
            </sect2>
        </sect1>
        <sect1 id="art2-1">
            <title>Примеры работ</title>
      <sect2>
        <title>Evoxy: libev-based HTTP proxy</title>
        <para><synopsis>Год: 2016
Инструментарий: С++11, POSIX, libev
Ссылка на Github: <ulink url="https://github.com/midenok/evoxy">Evoxy</ulink></synopsis>Пример
          не демонстрирует навыки реверсинга. Однако, это то чем я занимаюсь на данный момент,
          поэтому стоит его здесь указать. </para>
        <para>Программа написана на C++ с использованием элементов 11-го стандарта. Архитектура
          демона основана на неблокирующихся сокетах и состоит из пула потоков, в каждом из которых
          запущен цикл событий, обрабатывающий все принятые в данном потоке соединения. Программа
          работает на преаллоцированной памяти, у каждого потока есть свой пул памяти, аллокация из
          кучи происходит только на стадии инициализации приложения. Из пула блок памяти берётся при
          новом соединении и возвращается обратно при закрытии соединения. Вся обработка соединения
          происходит на статической памяти внутри этого блока. Подробнее об архитектуре приложения
          можно узнать из <ulink url="https://github.com/midenok/server-demo/blob/master/README.md"
            >описания</ulink> к моему проекту server-demo.</para>
        <para>Текущий статус проекта: основная функциональность RFC 2616 реализована, проект
          находится на стадии альфа-тестирования. Программа успешно справляется со множеством
          длинных сhunked запросов через keep-alive соединение.</para>
      </sect2>
            <sect2>
                <title>Atomic Bomberman</title>
                <para>
                    <informaltable frame="void" width="100%" cellpadding="0" cellspacing="0">
            <col width="50%" align="left"/>
            <col width="50%" align="right"/>
            <thead/>
            <tbody>
              <tr>
                <td valign="bottom">
                  <synopsis>Год: 2013
Инструментарий: Ida Pro 6.1; Syser 1.99</synopsis>
                </td>
                <td align="right"><ulink url="images/atomic-bomberman.jpg"><inlinemediaobject>
                      <imageobject>
                        <imagedata fileref="images/atomic-bomberman.jpg" width="5cm" align="right"/>
                      </imageobject>
                    </inlinemediaobject></ulink></td>
              </tr>
            </tbody>
          </informaltable>
                </para>
                <para>В ходе анализа кода игры <ulink
            url="https://en.wikipedia.org/wiki/Atomic_Bomberman">Atomic Bomberman</ulink> были
          найдены функции, отвечающие за работу основного меню ($main_menu_loop), запуска новой игры
          ($new_game_options, $new_game_players, $new_game), работу настроек игры ($options_menu,
          $load_options), а также основные игровые переменные, такие как $newgame_goal_amount,
          $goal_type, $newgame_theme. Все символы с '$' были разработаны мной в процессе реверсинга,
          полный их список (73) можно посмотреть в <ulink url="files/bm95_discovered.map"
            >bm95_discovered.map</ulink>. Заметки по анализу находятся в <ulink
            url="files/bomberman.txt">bomberman.txt</ulink>.</para>
                <para><ulink url="images/BM95-IDA.png"><inlinemediaobject>
              <imageobject>
                <imagedata fileref="images/BM95-IDA.png" width="620" scalefit="1"/>
              </imageobject>
            </inlinemediaobject></ulink></para>
            </sect2>
      <sect2>
        <title>ARTiSAN Real-time Studio</title>
        <synopsis>Год: 2003(?)
Инструментарий: SoftICE, etc.</synopsis>
        <para>Исправляет требование лицензионного ключа. К сожалению, в этом и более ранних примерах
          история анализа не сохранялась. Breakpoint ставился на GetWindowText(), который возвращал
          введённые пользователем данные. Затем происходил долгий и мучительный подъём по стеку (я
          тогда не анализировал пересечения стеков) до тех пор, пока не был найден условный переход
          после возврата с уровня, который активно "мурыжил" эти данные. Подправив этот условный
          переход -- вуаля: "Спасибо, что зарегистрировались!". </para>
        <programlisting language="cpp" linenumbering="numbered">#include &lt;io.h>
#include &lt;stdio.h>
#include &lt;fcntl.h>
#include &lt;sys/stat.h>
#include &lt;mem.h>

#define MAXBUF 100
char buf[MAXBUF];
char * filename = "rtsme.exe";
#define FILESIZE 6553600
#define LENGTH 5
char check[LENGTH] = { 0xe8, 0xa6, 0x05, 0xf2, 0xff };
char patch[LENGTH] = { 0x33, 0xc0, 0x40, 0x90, 0x90 };
#define OFFSET 0xe91c8

#define msgh(handle, fmt) fprintf(handle, fmt, filename)
#define err(fmt) msgh(stderr, fmt)
#define msg(fmt) msgh(stdout, fmt)

int main()
{
	int f;
	struct stat s;
	char buf[LENGTH];
	printf("ARTiSAN Real-time Studio v4.2.48.0 dirty crack by +....\n");
	if ((f = open(filename, O_RDWR))==-1) {
		err("Error opening %s!\n");
		return 1;
	}
	fstat(f, &amp;s);
	if (s.st_size != FILESIZE) {
		err("%s size mismatch!\n");
		return 1;
	}
	lseek(f, OFFSET, SEEK_SET);
	read(f, buf, LENGTH);
	if (memcmp(buf, check, LENGTH)) {
		err("Maybe %s already patched?\n");
		return 1;
	}
	lseek(f, OFFSET, SEEK_SET);
	if (LENGTH==write(f, patch, LENGTH)) {
		msg("%s successfully patched.\n");
		return 0;
	}
	err("Failed to write %s!\n");
	return 1;
}</programlisting>
      </sect2>
      <sect2>
        <title>SecureCRT</title>
        <synopsis>Год: 2002(?)
Инструментарий: SoftICE, etc.</synopsis>
        <para>Исправляет жалобу программы на плохую лицензию. В этом примере, как и было сказано в
            <link linkend="method_difficulties">описании методики</link>, данные, прочитанные из
          файла по цепочке перекладывались с места на место.</para>
        <para>
          <programlisting language="cpp" linenumbering="numbered">#include &lt;stdio.h>
#include &lt;string.h>
#pragma hdrstop

const char * EXENAME = "SecureCRT.exe";
const size_t OFFSET = 0x48d5f;
#define CHECKLEN 17
typedef unsigned char byte_t;
const byte_t CHECK[CHECKLEN] = {0x84, 0xc0, 0x0f, 0x84, 0x84,
        0, 0, 0, 0x8d, 0x4c, 0x24, 0x6c, 0xe8, 0xd6, 0x98,
        7, 0};
#pragma argsused
int main(int argc, char* argv[])
{
        char buf[CHECKLEN];
        FILE * exe = fopen(EXENAME, "r+");
        printf ("One byte crack by +.... for SecureCRT 4.1.0.138\n");
        if (! exe) {
                fprintf(stderr, "Open %s failed!\n", EXENAME);
                return 1;
        }
        fseek(exe, OFFSET, 0);
        if (CHECKLEN != fread(buf, 1, CHECKLEN, exe)) {
                fprintf(stderr, "Read %s failed!\n", EXENAME);
                return 1;
        }
        if (memcmp(buf, CHECK, CHECKLEN)) {
                fprintf(stderr, "Check %s failed!\n", EXENAME);
                return 1;
        }
        fseek(exe, OFFSET, 0);
        fprintf(exe, "\x32");
        fclose(exe);
        printf ("0x32 written at 0x%x.\
Now all protocols work with all these 4.0 licenses you can find on astalavista\
and usenet. Enjoy!\n", OFFSET);
        return 0;
}</programlisting>
        </para>
      </sect2>
            <sect2>
                <title>Windows XP: подключение к адресному пространству процесса</title>
                <para>
          <synopsis>Год: 2002</synopsis>
        </para>
        <para>Пример демонстрирует возможность вторжения в адресное пространство процесса. Основано
          на статье от
          +z0mbie.<programlisting language="cpp" os="windows" linenumbering="numbered">//---------------------------------------------------------------------------
#include &lt;iostream>
#include &lt;windows.h>
#pragma hdrstop

using namespace std;
//---------------------------------------------------------------------------

#pragma argsused
int main(int argc, char* argv[])
{
    LPCTSTR app = "&lt;path to EXE>";
    STARTUPINFO i = {0};
    i.cb = sizeof(STARTUPINFO);
    i.lpDesktop = "WinSta0\\Default";
    PROCESS_INFORMATION p;
	bool res = CreateProcess(app, NULL, NULL, NULL, TRUE,
    	NULL, NULL, NULL, &amp;i, &amp;p);
    if (!res) {
        DWORD e = GetLastError();
        char msg[50];
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, e, 0x419, msg, 49, NULL);
        cout &lt;&lt; "Process creation error: "&lt;&lt;msg&lt;&lt;"\n";
        return 1;
    } else {
        cout &lt;&lt; "Process created. About to change context: press any key... ";
        getchar();
    }
    CONTEXT tc;
    res = GetThreadContext(p.hThread, &amp;tc);
    if (!res) {
        cout &lt;&lt; "GetThreadContext: error\n";
        return 1;
    }
    res = SetThreadContext(GetCurrentThread(), &amp;tc);
    if (!res) {
        cout &lt;&lt; "SetThreadContext: error\n";
        return 1;
    }
    WORD b = *(int *)0x40569d; // type interesting address inside EXE
    cout &lt;&lt; "All is well "&lt;&lt; b &lt;&lt; "\n";
    getchar();
    return 0;
}
//---------------------------------------------------------------------------</programlisting></para>
            </sect2>
        </sect1>
    </chapter>
</book>
